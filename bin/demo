#!/usr/bin/env bash
set -e

msg() { echo -e "\e[32mINFO [$(date +%F_%H-%M-%S)] ---> $1\e[0m"; }
yellow() { echo -e "\e[33m$1\e[0m"; }
err() { echo -e "\e[31mERR [$(date +%F_%H-%M-%S)] ---> $1\e[0m" ; exit 1; }

#### Checking  
[ -z "$VAULT_ADDR" ] && err "Need to set VAULT_ADDR"
[ -z "$ROOT_TOKEN" ] && err "Need to set ROOT_TOKEN"
#: "${ROOT_TOKEN:?Need to set ROOT_TOKEN non-empty}"

echo "Vault URL is: $VAULT_ADDR"
# echo "Root token is: $ROOT_TOKEN"

msg "Printing vault status"
vault status

msg "Authenticating Vault using that token grants us root access to Vault"
vault login $ROOT_TOKEN

if [ $? == 0 ]; then
  msg "You are successfully authenticated with root token"
fi

msg "Let\'s write several secrets. The first secret is a pair" yellow "key1=secret1" msg "to the path" yellow "secret/first"
vault kv put secret/first key1=secret1

msg "The second secret is a pair" yellow "key2=secret2" msg "to the path" yellow "secret/super-secret"
vault kv put secret/super-secret key2=secret2

# Defining policy names
POLICY_NAME_1=read-write-policy

msg "Defining read-write policy"
vault policy write $POLICY_NAME_1 - << EOF
# This section grants all access on "secret/*". Further restrictions can be
# applied to this broad policy, as shown below.
path "secret/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}

# Even though we allowed secret/*, this line explicitly denies
# secret/super-secret. This takes precedence.
path "secret/super-secret" {
  capabilities = ["deny"]
}
EOF
if [ $? == 0 ]; then
  msg "Policy with the '$POLICY_NAME_1' name is successfully created "
fi
msg "List policies"
vault policy list

msg "Creating token and associating it with" yellow "$POLICY_NAME_1" msg "policy"
vault token create -policy $POLICY_NAME_1

#msg "Authenticating with newly created token"